= UFRN - Processamento Digital de Imagens (DCA0445)
Leonardo Carvalho Amaral
:toc: left
:toc-title: Sumário
:doctype: book

== Prefácio
Esta página foi feita para expor os resultados encontrados nas atividades de Processamento Digital de Imagens do professor Agostinho Brito Júnior, realizadas pelo aluno Leonardo Carvalho Amaral.

== 1. Exercício 1

[.text-justify]
O primeiro exercício consta em executar o código <<hello.cpp,hello.cpp>>, a fim de mostrar a imagem escolhida através do opencv, utilizando arquivo <<Makefile,Makefile>>.

[source,Makefile]
.Makefile
----
.SUFFIXEX:
.SUFFIXES: .CPP

GCC = g++

.cpp:
        &(GCC) -Wall -Wunused -std=c++11 -O2 $< -o $@ 'pkg-config --cflags --libs opencv4'
----

[source,hello.cpp]
.hello.cpp
----
#include <iostream>
#include <opencv2/opencv.hpp>

int main(int argc, char** argv){
  cv::Mat image;
  image = cv::imread(argv[1],cv::IMREAD_GRAYSCALE);
  cv::imshow("image", image);
  cv::waitKey();
  return 0;
}
----

[#biel]
.Biel
image::./Images/Exercicio_1/biel.png[align="center"]

== Exercício 2


== Projeto

[.text-justify]
O projeto escolhido foi de criar um efeito de traçados de luz de forma digital, pois a maneira habitual de se criar este efeito é através de mudar as configurações da câmera, a fim de manter o obturador totalmente aberto duramente a tomada da foto. Todavia, para alguém que não possua uma câmera que permita a mudança destas configurações, o programa <<traces.cpp,traces.cpp>> buscar recriar o mesmo efeito.

[source, traces.cpp]
.traces.cpp
----
#include <iostream>
#include <opencv2/opencv.hpp>

int main(int argc, char** argv){
    cv::Mat image, lixo, acumulador, media;
    cv::VideoCapture cap(argv[1]);
    int width, height;


    if(!cap.isOpened()){
        std::cout << "Error to load video" << std::endl;
        return -1;
    }

    width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
    height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);

    int fourcc = cv::VideoWriter::fourcc('P', 'I', 'M', '1');
    cv::Size framesize(static_cast<int>(width), static_cast<int>(height));
    cv::VideoWriter video("traces.avi",fourcc, 20, framesize, true);

    acumulador = cv::Mat::zeros(height,width, CV_8UC3);

    while(cap.isOpened()){
        cap >> image;
        for(int i = 0; i < height; i++){
            for(int j = 0; j < 3*width; j++){
                acumulador.at<uchar>(i,j) = std::max(acumulador.at<uchar>(i,j), image.at<uchar>(i,j));
            }
        }

        video.write(acumulador);
        if(cap.get(cv::CAP_PROP_POS_FRAMES) == cap.get(cv::CAP_PROP_FRAME_COUNT)) break;
    }

    cap.release();
    video.release();
    
    return 0;
}
----
[.text-justify]
O código segue os seguintes passos:
[.text-justify]
* Abre o arquivo de vídeo, checa suas dimensões e retorna caso o arquivo não tenha sido aberto corretamente;
* Começa a capturar os quadros e a cada quadro compara com o quadro anterior, buscando quais píxels tem maior tom de brílho utilizando a função <<std::max()>>;
* Após identificar todos os valores máximos de brilho de cada píxel dos quadros comparados, o quadro resultante é gravado no arquivo de saída em formato .avi;
* A condição de parada da captura de quadros é quando o frame atual se iguala ao último frame do arquivo.

Para o vídeo:
[#Original]
.Original
image::./Images/projeto/final.png[aling="center"]

[.text-justify]
Este é o resultado:
[#traces]
.Traces
image::./Images/projeto/traces.png[align="center]
